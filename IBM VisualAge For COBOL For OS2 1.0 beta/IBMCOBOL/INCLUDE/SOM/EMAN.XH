
/*
 * This file was generated by the SOM Compiler.
 * FileName: c:\somtk\include\eman.xh.
 * Generated using:
 *     SOM Precompiler somipc: 2.29.1.7
 *     SOM Emitter emitxh: 2.42
 */

/*
 * 
 *    COMPONENT_NAME: somu
 * 
 *    ORIGINS: 27
 * 
 * 
 *    10H9767, 10H9769  (C) COPYRIGHT International Business Machines Corp. 1992,1994
 *    All Rights Reserved
 *    Licensed Materials - Property of IBM
 *    US Government Users Restricted Rights - Use, duplication or
 *    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 * 
 */


#ifndef SOM_SOMEEMan_xh
#define SOM_SOMEEMan_xh

class SOMEEMan;

/*
 *  The Event Manager class (EMan for short) is used to handle several input
 *  events. The main purpose of this class is to provide a service that can do
 *  a blocked (or timed) wait on several event sources concurrently.  Typically,
 *  in a main program,  one registers an interest in an event type with EMan and
 *  specifies a callback (a procedure or a method) to be invoked when the event
 *  of interest occurs. After all the necessary registrations are done, the main
 *  program is ended by a call to process events in EMan. This call is non-returning.
 *  Eman then waits on multiple registered sources of events. The application is then
 *  completely event driven. I.E., it does something only when an event occurs.
 *  The control returns to EMan after processing each event. Further registrations
 *  can be done inside of callback routines. So also unregistrations.
 * 
 *  AIX Specifics:
 *  On AIX this event manager supports Timer, Sink (any file, pipe,
 *  socket and Message Queue), Client and WorkProc events.
 * 
 *  OS/2 Specifics:
 *  On OS/2 this event manager supports Timer, Sink(sockets only). Client and
 *  WorkProc events.
 *  To cope with multi-threaded applications on OS/2, the event manager
 *  methods are mutually exclusive (i.e., at any time only one thread can be
 *  executing inside of EMan).
 *  If an application thread needs to stop EMan from running (i.e., achieve
 *  mutual exclusion with EMan), it can use the two methods someGetEmanSem
 *  and someReleaseEManSem to acquire and release EMan semaphore(s).
 *  On AIX, at present, since AIX does not support threads calling these two methods
 *  has no effect.
 */

#define SOMEEMan_MajorVersion 2
#define SOMEEMan_MinorVersion 1

/* C++ SOM defs */
#include <somcls.xh>
#include <somcm.xh>

/* C++ parent defs */
#ifndef SOM_SOMObject_xh
#include <somobj.xh>
#endif

/*
 * C++ metaclass def
 */
#include <snglicls.xh>

#ifndef SOMEEMan_API
#define SOMEEMan_API
/*
 * -- The Class API
 */

/*
 * Start of user-defined types:
 */
class SOMClass;
class SOMObject;
class SOMEEvent;
class SOMEClientEvent;
class SOMEEMRegisterData;

/*
 * End of user-defined types.
 */

/*
 * Passthru lines: File: "C.xh", "after"
 */
extern "C" {
#include <emtypes.h>
}

/* A procedure to create the SOMEEMan Class */
class SOMMSingleInstance;
SOMEXTERN SOMMSingleInstance * SOMLINK SOMEEManNewClass(
		integer4 majorVersion,
		integer4 minorVersion);

/* The API to the SOMEEMan class object, and the methods it introduces. */
SOMEXTERN struct SOMEEManClassDataStructure {
	SOMMSingleInstance *classObject;
	somMToken someGetEManSem;
	somMToken someReleaseEManSem;
	somMToken someChangeRegData;
	somMToken someProcessEvent;
	somMToken someProcessEvents;
	somMToken someQueueEvent;
	somMToken someRegister;
	somMToken someRegisterEv;
	somMToken someRegisterProc;
	somMToken someShutdown;
	somMToken someUnRegister;
} SOMDLINK SOMEEManClassData;
#define _SOMEEMan SOMEEManClassData.classObject

/* The API to parentMtabs for SOMEEMan, and the instance data it introduces. */
SOMEXTERN struct SOMEEManCClassDataStructure {
	somMethodTabs parentMtab;
	somDToken              instanceDataToken;
} SOMDLINK SOMEEManCClassData;

/*
 * -- Typedefs for SOMEEMan Method Procedures
 */
SOMEXTERN {
typedef void   SOMLINK somTP_SOMEEMan_someGetEManSem(SOMEEMan *somSelf, Environment *ev);
typedef somTP_SOMEEMan_someGetEManSem *somTD_SOMEEMan_someGetEManSem;
typedef void   SOMLINK somTP_SOMEEMan_someReleaseEManSem(SOMEEMan *somSelf, Environment *ev);
typedef somTP_SOMEEMan_someReleaseEManSem *somTD_SOMEEMan_someReleaseEManSem;
typedef void   SOMLINK somTP_SOMEEMan_someChangeRegData(SOMEEMan *somSelf, Environment *ev,
		long registrationId,
		SOMEEMRegisterData* registerData);
typedef somTP_SOMEEMan_someChangeRegData *somTD_SOMEEMan_someChangeRegData;
typedef void   SOMLINK somTP_SOMEEMan_someProcessEvent(SOMEEMan *somSelf, Environment *ev,
		unsigned long mask);
typedef somTP_SOMEEMan_someProcessEvent *somTD_SOMEEMan_someProcessEvent;
typedef void   SOMLINK somTP_SOMEEMan_someProcessEvents(SOMEEMan *somSelf, Environment *ev);
typedef somTP_SOMEEMan_someProcessEvents *somTD_SOMEEMan_someProcessEvents;
typedef void   SOMLINK somTP_SOMEEMan_someQueueEvent(SOMEEMan *somSelf, Environment *ev,
		SOMEClientEvent* event);
typedef somTP_SOMEEMan_someQueueEvent *somTD_SOMEEMan_someQueueEvent;
typedef long   SOMLINK somTP_SOMEEMan_someRegister(SOMEEMan *somSelf, Environment *ev,
		SOMEEMRegisterData* registerData,
		SOMObject* targetObject,
		string targetMethod,
		void* targetData);
typedef somTP_SOMEEMan_someRegister *somTD_SOMEEMan_someRegister;
typedef long   SOMLINK somTP_SOMEEMan_someRegisterEv(SOMEEMan *somSelf, Environment *ev,
		SOMEEMRegisterData* registerData,
		SOMObject* targetObject,
		Environment* callbackEv,
		string targetMethod,
		void* targetData);
typedef somTP_SOMEEMan_someRegisterEv *somTD_SOMEEMan_someRegisterEv;
typedef long   SOMLINK somTP_SOMEEMan_someRegisterProc(SOMEEMan *somSelf, Environment *ev,
		SOMEEMRegisterData* registerData,
		EMRegProc* targetProcedure,
		void* targetData);
typedef somTP_SOMEEMan_someRegisterProc *somTD_SOMEEMan_someRegisterProc;
typedef void   SOMLINK somTP_SOMEEMan_someShutdown(SOMEEMan *somSelf, Environment *ev);
typedef somTP_SOMEEMan_someShutdown *somTD_SOMEEMan_someShutdown;
typedef void   SOMLINK somTP_SOMEEMan_someUnRegister(SOMEEMan *somSelf, Environment *ev,
		long registrationId);
typedef somTP_SOMEEMan_someUnRegister *somTD_SOMEEMan_someUnRegister;

/*
 * -- Typedefs for Reintroduced Wrapper Methods
 */
typedef SOMMSingleInstance*   SOMLINK somTP_SOMEEMan_somGetClass(SOMEEMan *somSelf);
typedef somTP_SOMEEMan_somGetClass *somTD_SOMEEMan_somGetClass;
}

#endif /* SOMEEMan_API */


/*
 * -- This emitter treats Method Tokens as Thunks by default.
 * -- Use the sc modifier "nothunks" to change this default
 */
#undef somresolve_
#define somresolve_(obj,mToken) ((somMethodProc*)((void)obj, mToken))

/*
 * -- The C++ Wrapper Class for SOMEEMan
 */
class SOMEEMan : public SOMObject
{
public:

// SOMEEMan::new creates the class object if necessary, and then uses somNewNoInit
// to allocate memory and create the object. Initialization is in ctors.
void *operator new(size_t)
{
   if (!_SOMEEMan) SOMEEManNewClass(SOMEEMan_MajorVersion,SOMEEMan_MinorVersion);
   return (void*)
      SOM_Resolve(_SOMEEMan,SOMClass,somNewNoInit)
         ((SOMClass *)((void*)_SOMEEMan));
}

// SOMEEMan::delete uses somDestruct.
void operator delete(void * obj)
{
   if (obj && *(void**)obj) {
      SOM_Resolve(obj,SOMObject,somDestruct)
         ((SOMObject*)obj, 1, 0);
   }
}

SOMEEMan()
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMEEManCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultInit(0);
}

SOMEEMan(SOMEEMan* fromObj)
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMEEManCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultCopyInit(0,((SOMObject*)((void*)fromObj)));
}

SOMEEMan(const SOMEEMan* fromObj)
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMEEManCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultConstCopyInit(0,((SOMObject*)((void*)fromObj)));
}


/* method: someGetEManSem */
void   someGetEManSem(Environment *ev)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someGetEManSem)
	(this, ev);
}


/* method: someReleaseEManSem */
void   someReleaseEManSem(Environment *ev)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someReleaseEManSem)
	(this, ev);
}


/* method: someChangeRegData */
void   someChangeRegData(Environment *ev,
		long registrationId,
		SOMEEMRegisterData* registerData)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someChangeRegData)
	(this, ev,registrationId,registerData);
}


/* method: someProcessEvent */
void   someProcessEvent(Environment *ev,
		unsigned long mask)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someProcessEvent)
	(this, ev,mask);
}


/* method: someProcessEvents */
void   someProcessEvents(Environment *ev)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someProcessEvents)
	(this, ev);
}


/* method: someQueueEvent */
void   someQueueEvent(Environment *ev,
		SOMEClientEvent* event)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someQueueEvent)
	(this, ev,event);
}


/* method: someRegister */
long   someRegister(Environment *ev,
		SOMEEMRegisterData* registerData,
		SOMObject* targetObject,
		string targetMethod,
		void* targetData)
{
   return SOM_ResolveD(this,SOMEEMan,SOMEEMan,someRegister)
	(this, ev,registerData,targetObject,targetMethod,targetData);
}


/* method: someRegisterEv */
long   someRegisterEv(Environment *ev,
		SOMEEMRegisterData* registerData,
		SOMObject* targetObject,
		Environment* callbackEv,
		string targetMethod,
		void* targetData)
{
   return SOM_ResolveD(this,SOMEEMan,SOMEEMan,someRegisterEv)
	(this, ev,registerData,targetObject,callbackEv,targetMethod,targetData);
}


/* method: someRegisterProc */
long   someRegisterProc(Environment *ev,
		SOMEEMRegisterData* registerData,
		EMRegProc* targetProcedure,
		void* targetData)
{
   return SOM_ResolveD(this,SOMEEMan,SOMEEMan,someRegisterProc)
	(this, ev,registerData,targetProcedure,targetData);
}


/* method: someShutdown */
void   someShutdown(Environment *ev)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someShutdown)
	(this, ev);
}


/* method: someUnRegister */
void   someUnRegister(Environment *ev,
		long registrationId)
{
   SOM_ResolveD(this,SOMEEMan,SOMEEMan,someUnRegister)
	(this, ev,registrationId);
}


/*
 * Reintroduce inherited methods
 */

/* method: somGetClass */
SOMMSingleInstance*  somGetClass()
{
   return SOM_ResolveD(this,SOMEEMan,SOMObject,somGetClass)
	(this);
}



};   /* SOMEEMan */



#endif       /* SOM_SOMEEMan_xh */
