
/******************************************************************************
*
*  Module Name: WSFILE.C
*
*  OS/2 Work Place Shell Sample Program
*
*  Copyright (C) 1995 IBM Corporation
*
*      DISCLAIMER OF WARRANTIES.  The following [enclosed] code is
*      sample code created by IBM Corporation. This sample code is not
*      part of any standard or IBM product and is provided to you solely
*      for  the purpose of assisting you in the development of your
*      applications.  The code is provided "AS IS", without
*      warranty of any kind.  IBM shall not be liable for any damages
*      arising out of your use of the sample code, even if they have been
*      advised of the possibility of such damages.
*
*  Entry Points:
*
*     Class Methods:
*
*        wsfM_clsQueryModuleHandle
*        wsfM_clsQueryDefaultFileText
*
*     Overridden Class Methods:
*
*        wsfM_wpclsInitData
*        wsfM_wpclsQueryDefaultHelp
*        wsfM_wpclsQueryDefaultView
*        wsfM_wpclsQueryDetailsInfo
*        wsfM_wpclsQueryIconData
*        wsfM_wpclsQueryInstanceFilter
*        wsfM_wpclsQueryStyle
*        wsfM_wpclsQueryTitle
*        wsfM_wpclsUnInitData
*
*     Instance Methods:
*
*        wsf_AddLastWorkerPage
*        wsf_soundAlarm
*        wsf_queryLastWorker
*        wsf_setLastWorker
*
*     Overridden Instance Methods:
*
*        wsf_wpAddSettingsPages
*        wsf_wpFilterPopupMenu
*        wsf_wpInitData
*        wsf_wpMenuItemHelpSelected
*        wsf_wpMenuItemSelected
*        wsf_wpModifyPopupMenu
*        wsf_wpOpen
*        wsf_wpQueryDetailsData
*        wsf_wpRestoreState
*        wsf_wpSaveState
*        wsf_wpUnInitData
*        wsf_wpFormatDragItem
*        wsf_wpSetup
*
*     Non-Method Functions:
*
*        WSFILEInit
*        WSFILEWndProc
*        LastWorkerDlgProc
*
******************************************************************************/

#include <string.h>
#include <stdio.h>
#include <memory.h>
#include <stdlib.h>

#define WSFILE_Class_Source
#define M_WSFILE_Class_Source
#include "wsfile.ih"         /* implementation header emitted from wsfile.idl */

/*
 * New Method: wpCnrRefreshDetails
 */
#define WPObject_wpCnrRefreshDetails(somSelf) \
    (SOM_Resolve(somSelf, WPObject, wpCnrRefreshDetails) \
        (somSelf))
#define _wpCnrRefreshDetails WPObject_wpCnrRefreshDetails

/*
 *   Non-Method function prototypes
 */

HWND             WSFILEInit(WSFILE *);
MRESULT EXPENTRY LastWorkerDlgProc( HWND hwnd, ULONG msg,
                                   MPARAM mp1, MPARAM mp2 );
MRESULT EXPENTRY WSFILEWndProc( HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2 );


/***************** GLOBAL/STATIC (NON-INSTANCE) DATA SECTION ******************
*****                                                                     *****
*****    This data shouldn't be changed by instance methods or it will    *****
*****    effect all instances!  Any variables that are specific (unique   *****
*****    values) for each instance of this object should be declared as   *****
*****  instance data or dynamically allocated and stored as window data.  *****
*****                                                                     *****
*****      This global data should be declared as class instance data     *****
*****    if it will change after initialization.  In this case, it will   *****
*****                  be accessed through class methods.                 *****
*****                                                                     *****
******************************************************************************/

   const char szWSFILEWindowClass[] =    "WSFILESAMPLE";
   const char szWSFILEInstanceFilter[] = "*.txt";
   const char szHelpLibrary[] =          "wsfile.hlp";
   UCHAR      szWSFILEClassTitle[CCHMAXPATH] = "";
   HMODULE    hmod = NULLHANDLE;

   /*
    *   Statics required for FIELDINFO structures needed for DETAILS view are
    *   handled in the three functions:
    *
    *   wsf_wpclsInitData, wsf_wpQueryDetailsData, wsf_wpQueryClassDetailsInfo
    */

   #define NUM_WSFILE_FIELDS    1

   CLASSFIELDINFO fieldinfo[NUM_WSFILE_FIELDS];      /* structure in wsfile.h */

   PCSZ apszWSFILEColTitles[] =
   {
      "Last Worker"           /* details column 1 */
   };


/*************************  INSTANCE METHODS SECTION  *************************
*****                                                                     *****
*****              Do not put any code in this section unless             *****
*****                   it is an object INSTANCE method                   *****
*****                                                                     *****
******************************************************************************/
#undef SOM_CurrentClass
#define SOM_CurrentClass SOMInstance


/*
 *
 *  METHOD: queryLastWorker                                ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Query name of last person to work with wsfile
 *
 *  RETURN:
 *
 *    PSZ            name of last person to work on file
 *
 */
SOM_Scope PSZ   SOMLINK wsf_queryLastWorker(WSFILE *somSelf)
{
    WSFILEData *somThis = WSFILEGetData(somSelf);
    WSFILEMethodDebug("WSFILE", "wsf_queryLastWorker");

    return _pszLastWorker;
} /* end wsf_queryLastWorker */

/*
 *
 * METHOD: setLastWorker                                  ( ) PRIVATE
 *                                                        (X) PUBLIC
 * DESCRIPTION:
 *
 *   Set name of last person to work with wsfile
 *
 * RETURN:
 *
 *   TRUE           Brake is on
 *   FALSE          Brake is off
 *
 */

SOM_Scope BOOL   SOMLINK wsf_setLastWorker(WSFILE *somSelf,
                PSZ pszWorkerName)
{
   BOOL rc = FALSE;

   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_setLastWorker");

   if (pszWorkerName)
   {
      if (_pszLastWorker)
      {
         _wpFreeMem(somSelf, (PBYTE) _pszLastWorker);
         _pszLastWorker = (PSZ)_wpAllocMem(somSelf, strlen(pszWorkerName) + 1,
                                           NULL);
         strcpy(_pszLastWorker, pszWorkerName);
         _wpCnrRefreshDetails(somSelf);
         rc = TRUE;
      }
   }
   return rc;
} /* end wsf_setLastWorker */

/*
 *
 *  METHOD: soundAlarm                                     ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Sound an alarm
 *
 *  RETURN:
 *
 *    TRUE           Successful
 *    FALSE          Unsuccessful
 *
 */
SOM_Scope BOOL   SOMLINK wsf_soundAlarm(WSFILE *somSelf)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_soundAlarm");

   DosBeep(100, 50);    /* beep and sleep.... */
   DosSleep(100);
   DosBeep(100, 30);
   DosSleep(100);
   DosBeep(100, 30);
   DosSleep(100);
   DosBeep(100, 50);
   DosSleep(100);
   DosBeep(100, 40);
   DosSleep(300);
   DosBeep(100, 100);
   DosSleep(100);
   DosBeep(100, 100);

   return TRUE;
} /* end wsf_soundAlarm */

/*
 *
 *  METHOD: AddLastWorkerPage                              ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    This method adds the Last Worker page to the settings notebook.
 *
 *  RETURN:
 *
 *    0              Unsuccessful
 *    ulPageId       Identifier for the inserted page
 *
 *  HOW TO OVERRIDE:
 *
 *    Method should always be overridden in order to replace or remove
 *    the last worker page from an object which is a descendent of wsfile.
 *    In most cases, an override of this method will not call the parent.
 *
 */
SOM_Scope ULONG   SOMLINK wsf_AddLastWorkerPage(WSFILE *somSelf,
                HWND hwndNotebook)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   PAGEINFO pageinfo;
   WSFILEMethodDebug("WSFILE", "wsf_AddLastWorkerPage");

   memset((PCH)&pageinfo, 0, sizeof(PAGEINFO));
   pageinfo.cb                 = sizeof(PAGEINFO);
   pageinfo.hwndPage           = NULLHANDLE;
   pageinfo.usPageStyleFlags   = BKA_MAJOR;
   pageinfo.usPageInsertFlags  = BKA_FIRST;
   pageinfo.pfnwp              = LastWorkerDlgProc;
   pageinfo.resid              = hmod;
   pageinfo.dlgid              = IDD_LASTWORKER;
   pageinfo.pszName            = "LastWorker";
   pageinfo.pCreateParams      = somSelf;
   pageinfo.idDefaultHelpPanel = ID_HELP_LASTWORKER;
   pageinfo.pszHelpLibraryName = (PSZ)szHelpLibrary;

   return _wpInsertSettingsPage( somSelf, hwndNotebook, &pageinfo );

}   /* end wsf_AddLastWorkerPage() */


/*
 *
 *  OVERRIDE: wpInitData                                   ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Initialize our state variables. Allocate any extra memory that
 *    we might need.
 *
 */
SOM_Scope void SOMLINK wsf_wpInitData(WSFILE *somSelf)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpInitData");

   parent_wpInitData(somSelf);

   _pszLastWorker = (PSZ)_wpAllocMem(somSelf, CCHMAXPATH + 1, NULL);
   if (_pszLastWorker)
   {
      strcpy(_pszLastWorker, DEFAULT_LASTWORKER);
   }
}   /* end wsf_wpInitData() */

/*
 *
 *  OVERRIDE: wpUnInitData                                 ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Clear up memory that was allocated on wpInitData.
 *
 */
SOM_Scope void   SOMLINK wsf_wpUnInitData(WSFILE *somSelf)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpUnInitData");

   if (_pszLastWorker)
   {
      _wpFreeMem(somSelf, (PBYTE)_pszLastWorker);
   }
   parent_wpUnInitData(somSelf);

}   /* end wsf_wpUnInitData() */


/*
 *
 *  METHOD: wpSaveState                                    ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Save our instance variable (last worker)
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpSaveState(WSFILE *somSelf)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpSaveState");

   _wpSaveString( somSelf, szWSFILEClassTitle,
                  IDKEY_LASTWORKER, _pszLastWorker);

   return parent_wpSaveState(somSelf);

}   /* end wsf_wpSaveState() */

/*
 *
 *  METHOD: wpRestoreState                                 ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Retrieve our saved instance variable (last worker)
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpRestoreState(WSFILE *somSelf, ULONG ulReserved)
{
   ULONG cbString;
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpRestoreState");

   _wpRestoreString( somSelf, szWSFILEClassTitle,
                      IDKEY_LASTWORKER, _pszLastWorker, &cbString );

   return parent_wpRestoreState(somSelf, ulReserved);
}   /* wsf_wpRestoreState() */


/*
 *
 *  METHOD: wpAddSettingsPages                             ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Add our own settings page to let the user modify the Last Worker's name
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpAddSettingsPages(WSFILE *somSelf, HWND hwndNotebook)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpAddSettingsPages");

   if (parent_wpAddSettingsPages(somSelf, hwndNotebook)
             && _AddLastWorkerPage(somSelf, hwndNotebook))
   {
      return TRUE;
   }
   else
   {
       DebugBox("wsf_wpAddSettingsPages", " Failed to add a settings page.");
       return FALSE;
   }
}   /* wsf_wpAddSettingsPages() */

/*
 *
 *  METHOD: wpFilterPopupMenu                              ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Filter out any options from the context that don't apply (we take
 *    out "create shadow"
 *
 *  HOW TO OVERRIDE:
 *
 *    No restrictions.
 *
 */
SOM_Scope ULONG SOMLINK wsf_wpFilterPopupMenu(WSFILE *somSelf,
                                              ULONG ulFlags,
                                              HWND hwndCnr,
                                              BOOL fMultiSelect)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpFilterPopupMenu");

    /*
     *   This method allows you to filter which menus to include in the
     *   popup menu.  Note: wpclsQueryStyle is overridden to disallow
     *   linking (creating shadow) as well.
     */
   return (parent_wpFilterPopupMenu(somSelf, ulFlags, hwndCnr,
                    fMultiSelect) & ~CTXT_LINK );

}   /* end wsf_wpFilterPopupMenu() */

/*
 *
 *  METHOD: wpModifyPopupMenu                              ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Add our extra options to the context menu
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpModifyPopupMenu(WSFILE *somSelf,
                                             HWND hwndMenu,
                                             HWND hwndCnr,
                                             ULONG iPosition)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpModifyPopupMenu");

    /*
     *   Put in our special "open wsfile" submenu item under the "open" menu
     */
   _wpInsertPopupMenuItems( somSelf, hwndMenu, 0,
                               hmod, ID_OPENMENU, WPMENUID_OPEN);
    /*
     *   insert a "beep horn" menu item at the end of the list.
     */
   _wpInsertPopupMenuItems( somSelf, hwndMenu, iPosition,
                               hmod, ID_ALARMMENU, 0 );

   return parent_wpModifyPopupMenu(somSelf, hwndMenu, hwndCnr, iPosition);
}   /* end wsf_wpModifyPopupMenu() */

/*
 *
 *  METHOD: wpMenuItemSelected                             ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Process the extra menu options that we added.
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpMenuItemSelected(WSFILE *somSelf,
                                              HWND hwndFrame,
                                              ULONG MenuId)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpMenuItemSelected");

    /*
     *   Which of our menu items was selected?
     */
   switch( MenuId )
   {
      case IDM_OPENWSFILE:
         /*
          *   We could call wpOpen here, but, if the object is already opened,
          *   the following API determines whether the object should be
          *   resurfaced, or if multiple views are desired.
          */
         _wpViewObject(somSelf, NULLHANDLE, OPEN_WSFILE, 0);
         break;

       case IDM_SOUNDALARM:
          _soundAlarm(somSelf);
          break;

       default:
          return parent_wpMenuItemSelected(somSelf, hwndFrame, MenuId);
          break;
    }
    return TRUE;                                          /* we processed it */
}   /* end wsf_wpMenuItemSelected() */

/*
 *
 *  METHOD: wpMenuItemHelpSelected                         ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Process help for the extra menu options that we added.
 *
 */
SOM_Scope BOOL SOMLINK wsf_wpMenuItemHelpSelected(WSFILE *somSelf, ULONG MenuId)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpMenuItemHelpSelected");

   /* Which of our menu items was selected?   */
   switch( MenuId )
   {
      case IDM_SOUNDALARM:

         return _wpDisplayHelp(somSelf, ID_HELP_SOUNDALARM, (PSZ)szHelpLibrary);
         break;

      case IDM_OPENWSFILE:

         return _wpDisplayHelp(somSelf, ID_HELP_OPENWSFILE, (PSZ)szHelpLibrary);
         break;

      default:
         break;
   }

   return parent_wpMenuItemHelpSelected(somSelf, MenuId);

}   /* end wsf_wpMenuItemHelpSelected() */

/*
 *
 *  METHOD: wpQueryDetailsData                             ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Returns the wsfile specific data for the details view of this object.
 *    Sets the pointer (*ppDetailsData) to the beginning of the buffer
 *    into which the data is written.
 *
 */
SOM_Scope ULONG SOMLINK wsf_wpQueryDetailsData(WSFILE *somSelf,
                PVOID *ppDetailsData,
                PULONG pcp)
{
   PWSFILEDETAILS pWSFILEDetails;
   PBYTE       pSize;
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpQueryDetailsData");

   parent_wpQueryDetailsData(somSelf, ppDetailsData, pcp);

   if (ppDetailsData)                                          /* query data */
   {
      pWSFILEDetails                  = (PWSFILEDETAILS) *ppDetailsData;
      pWSFILEDetails->pszLastWorker   = _queryLastWorker(somSelf);

      /* point to buffer location after our details data */
      *ppDetailsData = ((PBYTE)(*ppDetailsData)) + sizeof(*pWSFILEDetails);

   }   /* end if (ppDetailsData) */
   else                                                /* query size of data */
   {
      *pcp += sizeof(*pWSFILEDetails);     /* caller is querying size of buffer */
   }

   return TRUE;
}   /* end wsf_wpQueryDetailsData() */

/*
 *
 *   METHOD: wpOpen                                         ( ) PRIVATE
 *                                                          (X) PUBLIC
 *   DESCRIPTION:
 *
 *     Opens the wsfile window.
 *
 */
SOM_Scope HWND SOMLINK wsf_wpOpen(WSFILE *somSelf, HWND hwndCnr, ULONG ulView,
                                  ULONG param)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   WSFILEMethodDebug("WSFILE", "wsf_wpOpen");

   switch (ulView)
   {
      case OPEN_WSFILE:

          /*
           *   Create a basic Frame and Client window for this instance.
           */
         return WSFILEInit(somSelf);

      default:
         return parent_wpOpen(somSelf, hwndCnr, ulView, param);

   }   /* end switch (ulView) */

}   /* end wsf_wpOpen() */


/*
 *
 *  METHOD: wpSetup                                        ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Specify Setup strings and do some initialization.  This method is
 *    invoked once an object is completely created, as well as on demand.
 *
 *  New Setup Strings parsed and processed by this override:
 *
 *             SOUND=(YES/NO)   YES will invoke _soundAlarm method
 *                              NO  will do nothing
 *
 *  Note:  We're also overriding this method to write some default data to the
 *         object's real filename.  This will give us something to look at
 *         if the user drag/drops us on an editor or selects the open/editor
 *         view.
 */
SOM_Scope BOOL   SOMLINK wsf_wpSetup(WSFILE *somSelf, PSZ pszSetupString)
{
   WSFILEData *somThis = WSFILEGetData(somSelf);
   ULONG  cbBytesWritten;        /* pointer to variable receiving byte count */
   APIRET rc;
   BOOL   fSuccess;
   HFILE  hf;                        /* pointer to variable for file handle */
   ULONG  ulAction;                  /* pointer to variable for action taken */
   CHAR   szObjectFilename[CCHMAXPATH];      /* buffer for wpQueryRealName() */
   ULONG  cb  = sizeof(szObjectFilename);
   PSZ    pszDefaultText;
   BOOL   rcParentCall;
   CHAR   szValue[CCHMAXPATH + 1];
   ULONG  cbBuffer;

   WSFILEMethodDebug("WSFILE", "wsf_wpSetup");

   /*
    *   When the object is created from scratch, put some default
    *   text into the file on the hard disk
    */

   fSuccess = _wpQueryRealName(      /* query full-pathname of object's file */
      somSelf,                                     /* pointer to this object */
      szObjectFilename,                                     /* return buffer */
      &cb,                                                  /* sizeof buffer */
      TRUE);                            /* request fully qualified pathname? */

   if (fSuccess)
   {
      rc =
      DosOpen((PSZ)szObjectFilename, &hf, &ulAction,
         0UL,                           /* file size if created or truncated */
         FILE_NORMAL,                                      /* file attribute */
         FILE_OPEN             /* action taken if file exists/does not exist */
            | FILE_CREATE,
         OPEN_ACCESS_READWRITE                          /* open mode of file */
            | OPEN_SHARE_DENYNONE,
         (PEAOP2)NULL);      /* pointer to structure for extended attributes */

      if (rc)
      {
         CHAR ach[10];

         _ltoa(rc, ach, 10);
         DebugBox("wsf_wpSetup:DosOpen failed rc =", ach);
      }
      else
      {
         pszDefaultText = _clsQueryDefaultFileText(_WSFILE);
         DosWrite(hf, pszDefaultText, strlen(pszDefaultText), &cbBytesWritten);
         DosClose(hf);
      }
   }   /* end if (fSuccess) */

   rcParentCall = parent_wpSetup(somSelf, pszSetupString);

   /*
    *  Now that parent has processed all its setup strings, we'll take a
    *  look for setup strings that we understand.
    */
   cbBuffer = CCHMAXPATH;
   if (_wpScanSetupString(somSelf, pszSetupString, "SOUND", szValue, &cbBuffer))
   {
      if ((szValue[0] == 'Y') && (szValue[1] == 'E') && (szValue[2] == 'S'))
      {
         _soundAlarm(somSelf);
      }
   }

   return rcParentCall;
}   /* end wsf_wpSetup() */


/*
 * METHOD: wpFormatDragItem                              ( ) PRIVATE
 *                                                       (X) PUBLIC
 * DESCRIPTION:
 *
 *   Specify a unique RMF that will only be understood by instances
 *   of class WSFOLDER.  (see _wpDragOver and _wpDrop overrides in
 *   wsfolder.c).
 */
SOM_Scope BOOL   SOMLINK wsf_wpFormatDragItem(WSFILE *somSelf,
                PDRAGITEM pdrgItem)
{
/*  WSFILEData *somThis = WSFILEGetData(somSelf); */
   WSFILEMethodDebug("WSFILE", "wsf_wpFormatDragItem");

   parent_wpFormatDragItem(somSelf, pdrgItem);

    /* We do NOT want to really let the workplace shell render
     * our object, so change the rendering mechanism and format
     * to be uniquely ours.
     */
   DrgDeleteStrHandle(pdrgItem->hstrRMF);

   pdrgItem->hstrRMF = DrgAddStrHandle("<DRM_OUROWNSPECIAL,DRF_OBJECT>");

   return TRUE;
}


/**************************  CLASS METHODS SECTION  ***************************
*****                                                                     *****
*****              Do not put any code in this section unless             *****
*****                     it is an object CLASS method                    *****
*****                                                                     *****
******************************************************************************/
#undef SOM_CurrentClass
#define SOM_CurrentClass SOMMeta


/*
 *
 *  METHOD: clsQueryModuleHandle                           ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    This method returns the module handle of this class.  If this is the
 *    first invocation, DosQueryModuleHandle is called to save the handle
 *    for future invocations.
 *
 *  RETURN:
 *
 *    0              Unsuccessful
 *    non-zero       module handle
 *
 */
SOM_Scope HMODULE   SOMLINK wsfM_clsQueryModuleHandle(M_WSFILE *somSelf)
{
   APIRET rc;

    /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_clsQueryModuleHandle");

   /*
    *   Make sure we already have module handle
    */

   if (hmod == NULLHANDLE)
   {
      zString zsPathName;
       /*
        *   Retrieve registered pathname of our module (DLL) and query the
        *   module handle.
        */
      zsPathName = _somLocateClassFile( SOMClassMgrObject,
                                        SOM_IdFromString("WSFILE"),
                                        WSFILE_MajorVersion,
                                        WSFILE_MinorVersion);
      rc = DosQueryModuleHandle( zsPathName, &hmod);
      if (rc)
      {
         DebugBox("wsfM_wpclsInitData", "Failed to load module");
         return;
      }
   }   /* end if (hmod == NULLHANDLE) */

   return hmod;
}   /* end wsfM_clsQueryModuleHandle() */



/*
 *
 *  METHOD: clsQueryDefaultFileText                        ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    This method returns some default text to stuff in an empty WSFILE.
 *
 *  RETURN:
 *
 *    PSZ
 *
 */
SOM_Scope PSZ   SOMLINK wsfM_clsQueryDefaultFileText(M_WSFILE *somSelf)
{
    /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_clsQueryDefaultFileText");

   return (PSZ)"This is an empty file of class WSFILE";
} /* end wsfM_clsQueryDefaultFileText */

/*
 *
 *  METHOD: wpclsQueryStyle                                ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *     The wpclsQueryStyle method is called to allow the class object
 *     to specify the default object class style for its instances.
 *
 *  REMARKS:
 *
 *     This method can be called at any time in order to determine the
 *     default style for instances of this class.
 *
 *     This method should be overridden in order to modify the default
 *     object style for instances of this class.
 *
 */
SOM_Scope ULONG   SOMLINK wsfM_wpclsQueryStyle(M_WSFILE *somSelf)
{
    /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
    M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryStyle");

    /*
     *   Modify style bits as described in programming reference.  This
     *   particular style (link) is also disabled in wpFilterPopupMenu()
     */
   return (parent_wpclsQueryStyle(somSelf) | CLSSTYLE_NEVERLINK );
}

/*
 *
 *  METHOD: wpclsInitData                                  ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Initialize the class data
 *
 */
SOM_Scope void SOMLINK wsfM_wpclsInitData(M_WSFILE *somSelf)
{
    /* M_WSFILEData *somThis  = M_WSFILEGetData(somSelf); */
    ULONG rc, i;
    PCLASSFIELDINFO pCFI;
    M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsInitData");

    /*
     *   Call the parent class method first
     */
    parent_wpclsInitData(somSelf);

    /*
     *   Get class title
     */
    if (!WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP),
                       _clsQueryModuleHandle(somSelf),
                       ID_TITLE,
                       sizeof(szWSFILEClassTitle), szWSFILEClassTitle))
       /* Load string failed: use the parent's string */
       strcpy(szWSFILEClassTitle, parent_wpclsQueryTitle(somSelf));

   /*
    *   Initialize everything needed for the CLASSFIELDINFO structures
    *   for the WSFILE object class
    */

   for (i = 0, pCFI = fieldinfo; i < NUM_WSFILE_FIELDS; i++, pCFI++)
   {
      memset((PCH) pCFI, 0, sizeof(CLASSFIELDINFO));               /* zeroes */

      pCFI->cb        = sizeof(CLASSFIELDINFO);
      pCFI->flData    = CFA_RIGHT | CFA_SEPARATOR | CFA_FIREADONLY;
      pCFI->flTitle   = CFA_CENTER | CFA_SEPARATOR | CFA_HORZSEPARATOR |
                        CFA_STRING | CFA_FITITLEREADONLY;
      pCFI->pNextFieldInfo = pCFI + 1;       /* point to next CLASSFIELDINFO */
      pCFI->pTitleData = (PVOID) apszWSFILEColTitles[i];
      pCFI->flCompare  = COMPARE_SUPPORTED | SORTBY_SUPPORTED;

      switch (i)
      {
         case INDEX_LASTWORKER:

            pCFI->flData           |= CFA_STRING;
            pCFI->offFieldData      = (ULONG)(FIELDOFFSET(WSFILEDETAILS, pszLastWorker));
            pCFI->ulLenFieldData    = sizeof(PSZ);
            pCFI->DefaultComparison = CMP_EQUAL;

            break;

      }   /* end switch(i) */

   }   /* end for (i=0, pCFI=fieldinfo; i < NUM_WSFILE_FIELDS; i++, pCFI++)  */

   fieldinfo[NUM_WSFILE_FIELDS-1].pNextFieldInfo = NULL;  /* end linked list */

}   /* end wsfM_ wpclsInitData() */

/*
 *
 *  METHOD: wpclsUnInitData                                ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Free any class data
 *
 */
SOM_Scope void SOMLINK wsfM_wpclsUnInitData(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsUnInitData");

   /* nothing to free... */
   parent_wpclsUnInitData(somSelf);

}   /* end wsfM_wpclsUnInitData() */

/*
 *
 *  METHOD: wpclsQueryTitle                                ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Return the string "WSfile".
 *
 */
SOM_Scope PSZ SOMLINK wsfM_wpclsQueryTitle(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryTitle");

    /*
     *   Return the class title for a wsfile
     */

   if (*szWSFILEClassTitle )
      return szWSFILEClassTitle;
   else
      return parent_wpclsQueryTitle(somSelf);
}   /* end wsfM_wpclsQueryTitle() */

/*
 *
 *  METHOD: wpclsQueryIconDdata                            ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Return the class icon
 *
 */
SOM_Scope ULONG SOMLINK wsfM_wpclsQueryIconData(M_WSFILE *somSelf,
                  PICONINFO pIconInfo)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   APIRET rc;
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryIconData");

   if (pIconInfo)
   {
      /*
       *   fill in icon information
       */
      pIconInfo->fFormat = ICON_RESOURCE;
      pIconInfo->hmod    = _clsQueryModuleHandle(somSelf);
      pIconInfo->resid   = ID_ICON;
   }
   return sizeof(ICONINFO);
}   /* end wsfM_wpclsQueryIconData() */

/*
 *
 *  METHOD: wpclsQueryDefaultHelp                          ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Process input from the extra menu option that we added.
 *
 */
SOM_Scope BOOL SOMLINK wsfM_wpclsQueryDefaultHelp(M_WSFILE *somSelf,
                PULONG pHelpPanelId,
                PSZ pszHelpLibrary)
{
 /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
    M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryDefaultHelp");

    if (pHelpPanelId)                           /* set default help panel id */
       *pHelpPanelId   = ID_HELP_DEFAULT;

    if (pszHelpLibrary)                                /* copy help filename */
       strcpy(pszHelpLibrary, szHelpLibrary);

    return TRUE;

}   /* end wsfM_wpclsQueryDefaultHelp() */

/*
 *
 *  METHOD: wpclsQueryDefaultView                          ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Returns the default view for a new instance of this object.
 *
 *  REMARKS:
 *
 *    Tell the system what our default open view is...
 *
 */
SOM_Scope ULONG SOMLINK wsfM_wpclsQueryDefaultView(M_WSFILE *somSelf)
{
 /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryDefaultView");

   return OPEN_WSFILE;
}   /* end wsfM_wpclsQueryDefaultView() */

/*
 *
 *  METHOD: wpclsQueryDetailsInfo                          ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *    Appends the wsfile specific chain of FIELDINFO structures describing the
 *    details data of this object to *ppClassFieldInfo (if ppClassFieldInfo
 *    is NON-NULL).  In this case it also sets *ppClassFieldInfo to the
 *    head of the linked list.
 *
 *    Adds the number of bytes required by the details data for wsfile to *pSize
 *    (if pSize is NON-NULL).
 *
 *  REMARKS:
 *
 *    Add details data for this object.
 *
 */
SOM_Scope ULONG SOMLINK wsfM_wpclsQueryDetailsInfo(M_WSFILE *somSelf,
                PCLASSFIELDINFO *ppClassFieldInfo,
                PULONG pSize)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   ULONG           cParentColumns;
   PCLASSFIELDINFO pCFI;
   ULONG           i;

   M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryDetailsInfo");

   /*
    *   Always call the parent method first to retrieve number of details
    *   columns and parent's data already defined in details buffer.
    */

   cParentColumns =
   parent_wpclsQueryDetailsInfo(somSelf, ppClassFieldInfo, pSize);

   /*
    *   If pSize is non-NULL, we must add the size of our details column
    *   data structure.
    */

   if (pSize)
      *pSize += sizeof(WSFILEDETAILS);                           /* adjust size */

   /*
    *   If the request was for the chained fieldinfo structures
    *   (ppClassFieldInfo is non-NULL), link them in
    *
    *   eventually the chain will look like
    *
    *   Grandad - Dad - Me - Kid - Grandkid
    *
    *   I will be getting the pointer to the beginning of the chain
    *
    *   If the beginning of the chain is 0, I will assign the address
    *   of ws first CLASSFIELDINFO structure to *ppClassFieldInfo.
    *   Otherwise *pp points to the first column description in the
    *   chain.  We need to walk the chain and link our CLASSFIELDINFO
    *   structures at the end.
    */

   if (ppClassFieldInfo)
   {
      /*
       *   Find the last link in the chain;  Then link our CLASSFIELDINFO
       *   structures to the chain.
       */

      if (*ppClassFieldInfo)
      {
         pCFI = *ppClassFieldInfo;
         for (i = 0; i < cParentColumns; i++)
            if (pCFI->pNextFieldInfo)
               pCFI = pCFI->pNextFieldInfo;

         pCFI->pNextFieldInfo = fieldinfo;
      }
      else
         *ppClassFieldInfo = fieldinfo;
   }
   return (ULONG)(cParentColumns + NUM_WSFILE_FIELDS);

}   /* end wsfM_wpclsQueryDetailsInfo() */

/*
 *
 *  METHOD: wpclsQueryInstanceFilter                       ( ) PRIVATE
 *                                                         (X) PUBLIC
 *  DESCRIPTION:
 *
 *     The wpclsQueryInstanceFilter method is called to allow the class
 *     object to specify the file title filters for instances of its
 *     class.
 *
 *  REMARKS:
 *
 *     A pointer to a string containing file title filter(s).  This
 *     string can contain several file title filters separated by a
 *     comma.  Example: "*.TXT, *.DOC"
 *
 *  Note:  Overriding this method will cause any data file with the extension
 *         ".txt" to become a data object of the class "WSFILE."
 *
 */
SOM_Scope PSZ   SOMLINK wsfM_wpclsQueryInstanceFilter(M_WSFILE *somSelf)
{
    /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
    M_WSFILEMethodDebug("M_WSFILE", "wsfM_wpclsQueryInstanceFilter");

    return (PSZ)szWSFILEInstanceFilter;
}


/**************************  ORDINARY CODE SECTION  ***************************
*****                                                                     *****
*****                  Any non-method code should go here.                *****
*****                                                                     *****
******************************************************************************/
#undef SOM_CurrentClass


/***************************************************************************
*                                                                          *
*       ROUTINE:    WSFILEInit ( )                                         *
*                                                                          *
*       DESCRIPTION:    WSFILE Initialization                              *
*                                                                          *
*       RETURNS:    Handle of wsfile frame window, NULL if error           *
*                                                                          *
***************************************************************************/
HWND WSFILEInit(WSFILE *somSelf)
{
   HWND hwndFrame = NULLHANDLE;                       /* Frame window handle */
   HWND hwndClient = NULLHANDLE;
   PWINDOWDATA pWindowData;
   BOOL fSuccess;
   SWCNTRL    swcEntry;                                      /* Switch Entry */
   FRAMECDATA flFrameCtlData;                              /* Frame Ctl Data */
   HAB hab = WinQueryAnchorBlock(HWND_DESKTOP);    /* PM anchor block handle */

   if (!WinRegisterClass(hab, (PSZ)szWSFILEWindowClass, (PFNWP)WSFILEWndProc,
                         CS_SIZEREDRAW | CS_SYNCPAINT, sizeof(pWindowData)))
   {
      DebugBox("WSFILEInit", "Failure in WinRegisterClass");
      return NULLHANDLE;
   }

   /*
    *   Allocate some instance specific data in Window words of Frame window.
    *   This will ensure our window procedure can use this object's methods
    *   (our window proc isn't passed a * somSelf pointer).
    */
   pWindowData = (PWINDOWDATA)_wpAllocMem(somSelf, sizeof(*pWindowData), NULL);

   if (!pWindowData)
   {
      DebugBox("WSFILEInit", "wpAllocMem failed to allocate pWindowData");
      return NULLHANDLE;
   }

   memset((PVOID) pWindowData, 0, sizeof(*pWindowData));
   pWindowData->cb = sizeof(*pWindowData);             /* first field = size */
   pWindowData->somSelf = somSelf;

   /* Create a frame window
    */
   flFrameCtlData.cb            = sizeof( flFrameCtlData );
   flFrameCtlData.flCreateFlags = FCF_SIZEBORDER | FCF_TITLEBAR | FCF_SYSMENU |
                                  FCF_MINMAX;
   flFrameCtlData.hmodResources = hmod;
   flFrameCtlData.idResources   = ID_ICON;

   hwndFrame =                                        /* create frame window */
   WinCreateWindow(
      HWND_DESKTOP,               /* parent-window handle                    */
      WC_FRAME,                   /* pointer to registered class name        */
      _wpQueryTitle(somSelf),     /* pointer to window text                  */
      0UL,                        /* window style                            */
      0L, 0L, 0L, 0L,             /* position of window                      */
      NULLHANDLE,                 /* owner-window handle                     */
      HWND_TOP,                   /* handle to sibling window                */
      ID_FRAME,                   /* window identifier                       */
      (PVOID) &flFrameCtlData,    /* pointer to buffer                       */
      NULL);                      /* pointer to structure with pres. params. */

   if (!hwndFrame)
   {
      DebugBox("WSFILEInit", "Failure in WinCreateWindow");
      return NULLHANDLE;
   }
   hwndClient =         /* use WinCreateWindow so we can pass pres params */
   WinCreateWindow(
      hwndFrame,               /* parent-window handle                    */
      (PSZ)szWSFILEWindowClass,/* pointer to registered class name        */
      (PSZ)NULL,               /* pointer to window text                  */
      0UL,                     /* window style                            */
      0L, 0L, 0L, 0L,          /* position of window                      */
      hwndFrame,               /* owner-window handle                     */
      HWND_TOP,                /* handle to sibling window                */
      FID_CLIENT,              /* window identifier                       */
      pWindowData,             /* pointer to buffer                       */
      NULL);                   /* pointer to structure with pres. params. */

   if (!hwndClient)
   {
      WinDestroyWindow(hwndFrame);
      return NULLHANDLE;
   }

   WinSendMsg(hwndFrame, WM_SETICON, MPFROMP(_wpQueryIcon(somSelf)), MPVOID);
   WinSetWindowText(WinWindowFromID(hwndFrame, FID_TITLEBAR),
                    _wpQueryTitle(somSelf));

   /*
    * Restore the Window Position
    */
   fSuccess = WinRestoreWindowPos( szWSFILEClassTitle,      /* class title */
                                   _wpQueryTitle(somSelf),  /* object title */
                                   hwndFrame);

   if (!fSuccess)
   {
    SWP        swp;

      /*
       * Get the dimensions and the shell's suggested
       * location for the window.
       */
      WinQueryTaskSizePos(hab, 0, &swp);

      /* Set the frame window position  */
      swp.fl = SWP_SIZE|SWP_MOVE|SWP_RESTORE|SWP_ZORDER;
      WinSetWindowPos(hwndFrame, HWND_TOP, swp.x, swp.y, swp.cx, swp.cy, swp.fl);
   }

   WinShowWindow(hwndFrame, TRUE);
   return hwndFrame;                                              /* success */

}   /* end WSFILEInit() */


/******************************************************************************
*
*   WSFILEWndProc()
*
*   DESCRIPTION: WSFILE Window Procedure
*
******************************************************************************/
MRESULT EXPENTRY WSFILEWndProc( HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2 )
{
  PWINDOWDATA pWindowData;
  HWND     hwndFrame;
  BOOL     fSuccess;

   hwndFrame = WinQueryWindow(hwnd, QW_PARENT);

   switch( msg )
   {
      case WM_CREATE:

        pWindowData = (PWINDOWDATA)mp1;

        if (pWindowData == NULL)
        {
           DebugBox("WSFILEWndProc:WM_CREATE", "couldn't get window words");
           return FALSE;
        }
        /*
         *   Fill in the class view/usage details and window specific data
         *   for this instance.
         */
        pWindowData->UseItem.type    = USAGE_OPENVIEW;
        pWindowData->ViewItem.view   = OPEN_WSFILE;
        pWindowData->ViewItem.handle = hwndFrame;

        /*
         *   Set window pointer with object pointer and instance view info.
         *   Then add view to the in-use list so wpSwitchTo works.
         */
        WinSetWindowPtr(hwnd, QWL_USER, pWindowData);
        _wpAddToObjUseList(pWindowData->somSelf, &pWindowData->UseItem);
        _wpRegisterView(pWindowData->somSelf, hwndFrame,
                        _wpQueryTitle(pWindowData->somSelf));
        WinSetFocus( HWND_DESKTOP, hwndFrame);
        break;

      case WM_COMMAND:

        break;

      case WM_PAINT:
         pWindowData = (PWINDOWDATA)WinQueryWindowPtr(hwnd, QWL_USER);

         if (pWindowData == NULL)
         {
            DebugBox("WSFILEWndProc:WM_PAINT", "couldn't get window words");
            return FALSE;
         }
         else
         {
          HPS    hps;
          RECTL  rectl;

           hps = WinBeginPaint( hwnd, (HPS)NULLHANDLE, &rectl);
           WinFillRect( hps, &rectl, SYSCLR_WINDOW);
           WinDrawPointer(hps, 50, 50,
                          _wpQueryIcon(pWindowData->somSelf), DP_NORMAL);
           WinEndPaint( hps );
         }
         break;

      case WM_CLOSE:
         {
            HAB hab = WinQueryAnchorBlock(HWND_DESKTOP);

            pWindowData = (PWINDOWDATA)WinQueryWindowPtr(hwnd, QWL_USER);

            if (pWindowData == NULL)
            {
               DebugBox("WSFILEWndProc:WM_CLOSE", "couldn't get window words");
               return FALSE;
            }
            /*
             * Restore the Window Position
             */
            fSuccess = WinStoreWindowPos(szWSFILEClassTitle,
                                         _wpQueryTitle(pWindowData->somSelf),
                                         hwndFrame);
            _wpDeleteFromObjUseList(pWindowData->somSelf, &pWindowData->UseItem);
            _wpFreeMem(pWindowData->somSelf, (PBYTE)pWindowData);

            WinPostMsg(hwnd, WM_QUIT, MPVOID, MPVOID);
            WinDestroyWindow(hwndFrame);
         }
         break;

      default:
         return WinDefWindowProc( hwnd, msg, mp1, mp2 );
   }
   return FALSE;

}   /* end WSFILEWndProc() */

/******************************************************************************
*
*   LastWorkerDlgProc()
*
*   DESCRIPTION: Dialog Procedure for LastWorker settings page
*
******************************************************************************/
MRESULT EXPENTRY LastWorkerDlgProc(HWND hwndDlg, ULONG msg,
                                  MPARAM mp1, MPARAM mp2)
{
   LASTWORKERDLGDATA *pLastWorkerDlgData;

   switch (msg)
   {
      case WM_INITDLG:          /* 0x003b */
      {
         PSZ       pszTemp;

         /*
          *   Store some instance specific data in Window words of this dialog.
          *   This will ensure our dialog procedure can access this objects
          *   data (our dialog proc isn't always passed a *somSelf pointer).
          */
         pLastWorkerDlgData =
            (PLASTWORKERDLGDATA)_wpAllocMem((WSFILE *)mp2,
                                            sizeof(*pLastWorkerDlgData), NULL);
         if (pLastWorkerDlgData)
         {
            memset((PVOID) pLastWorkerDlgData, 0, sizeof(*pLastWorkerDlgData));
            pLastWorkerDlgData->cb = sizeof(*pLastWorkerDlgData);
            pLastWorkerDlgData->somSelf = (WSFILE *)mp2;   /* pointer to this object */
            pszTemp = _queryLastWorker(pLastWorkerDlgData->somSelf);
            if (pszTemp)
            {
               pLastWorkerDlgData->PrevWorker =
                                  (PSZ)_wpAllocMem(pLastWorkerDlgData->somSelf,
                                  CCHMAXPATH + 1, NULL);
               if (pLastWorkerDlgData->PrevWorker)
               {
                  strcpy(pLastWorkerDlgData->PrevWorker, pszTemp);
               }
            }

            pLastWorkerDlgData->restorePrevWorker =
                        (PSZ) _wpAllocMem(pLastWorkerDlgData->somSelf,
                                           CCHMAXPATH + 1, NULL);
            if (pLastWorkerDlgData->restorePrevWorker)
            {
               strcpy(pLastWorkerDlgData->restorePrevWorker,
                      pLastWorkerDlgData->PrevWorker);
            }
         }
         else
         {
            DebugBox("LastWorkerDlgProc:WM_INITDLG", "Couldn't allocate window words");
            break;
         }

         WinSetWindowPtr(hwndDlg, QWL_USER, pLastWorkerDlgData);

         /* set the text limit on the entry field
          */
         WinSendDlgItemMsg( hwndDlg, IDC_LASTWORKER, EM_SETTEXTLIMIT,
                            MPFROMSHORT( 0x1000-1 ), 0 );

         /* set the name into the entry field
          */
         WinSetWindowText( WinWindowFromID( hwndDlg, IDC_LASTWORKER ),
                           _queryLastWorker( (WSFILE *)mp2) );

         return (MRESULT)FALSE;
      }   /* end case WM_INITDLG: */

      case WM_DESTROY:             /* 0x0002 */
      {
         WSFILE *pObject;

         pLastWorkerDlgData = WinQueryWindowPtr(hwndDlg, QWL_USER);
         if (pLastWorkerDlgData == NULL)
         {
            DebugBox("LastWorkerDlgProc:WM_DESTROY", "couldn't get window words");
            break;
         }

         if (pLastWorkerDlgData->PrevWorker)
         {
            _wpFreeMem(pLastWorkerDlgData->somSelf,
                       (PBYTE) pLastWorkerDlgData->PrevWorker);
         }

         if (pLastWorkerDlgData->restorePrevWorker)
         {
            _wpFreeMem(pLastWorkerDlgData->somSelf,
                       (PBYTE) pLastWorkerDlgData->restorePrevWorker);
         }

         pObject = pLastWorkerDlgData->somSelf;
         _wpFreeMem(pObject, (PBYTE)pLastWorkerDlgData);
         return WinDefDlgProc(hwndDlg, msg, mp1, mp2);
      }

      case WM_COMMAND:           /* 0x0020 */

         pLastWorkerDlgData = WinQueryWindowPtr(hwndDlg, QWL_USER);
         if (pLastWorkerDlgData == NULL)
         {
            DebugBox("LastWorkerDlgProc:WM_COMMAND", "couldn't get window words");
            break;
         }

         switch (SHORT1FROMMP(mp1))
         {
            case ID_UNDO:                   /* 0x0321 */
               if (pLastWorkerDlgData->restorePrevWorker)
               {
                  _setLastWorker(pLastWorkerDlgData->somSelf,
                                 pLastWorkerDlgData->restorePrevWorker);

                  if (pLastWorkerDlgData->PrevWorker)
                  {
                     strcpy(pLastWorkerDlgData->PrevWorker,
                            pLastWorkerDlgData->restorePrevWorker);
                  }
                  WinSetWindowText( WinWindowFromID( hwndDlg, IDC_LASTWORKER ),
                                    pLastWorkerDlgData->restorePrevWorker);
               }
               break;

            case ID_DEFAULT:             /* 0x0322 */
               /*
                *   preserve previous values
                */
               _setLastWorker(pLastWorkerDlgData->somSelf, DEFAULT_LASTWORKER);

               if (pLastWorkerDlgData->PrevWorker)
               {
                  strcpy(pLastWorkerDlgData->PrevWorker, DEFAULT_LASTWORKER);
               }

               WinSetWindowText( WinWindowFromID( hwndDlg, IDC_LASTWORKER ),
                                 pLastWorkerDlgData->PrevWorker);

               break;

            case ID_HELP:         /* 0x0323 */

               break;

         }   /* end switch (SHORT1FROMMP(mp1)) */

         return (MRESULT)TRUE;

      case WM_CONTROL:          /* 0x0030 */
      {
         pLastWorkerDlgData = WinQueryWindowPtr(hwndDlg, QWL_USER);
         if (pLastWorkerDlgData == NULL)
         {
            DebugBox("LastWorkerDlgProc:WM_CONTROL", "couldn't get window words");
            break;
         }

         switch (SHORT1FROMMP(mp1))
         {
         case IDC_LASTWORKER:
            if (SHORT2FROMMP(mp1) == EN_CHANGE)
            {
               CHAR newworker[CCHMAXPATH + 1];

               WinQueryWindowText( WinWindowFromID( hwndDlg, IDC_LASTWORKER),
                                   CCHMAXPATH + 1, newworker );
               _setLastWorker(pLastWorkerDlgData->somSelf, newworker);
               if (pLastWorkerDlgData->PrevWorker)
               {
                  strcpy(pLastWorkerDlgData->PrevWorker, newworker);
               }
            }

            return (MRESULT)TRUE;
         }
         break;

      }   /* end case WM_CONTROL: */

   }   /* end switch (msg) */

   return WinDefDlgProc(hwndDlg, msg, mp1, mp2);

}   /* end LastWorkerDlgProc() */


/********************************  END wsfile.c  ********************************/




/*
 *
 * METHOD: clsQueryModuleHandle                           ( ) PRIVATE
 *                                                        (X) PUBLIC
 * DESCRIPTION:
 *
 *   This method returns the module handle of this class.  If this is the
 *   first invocation, DosQueryModuleHandle is called to save the handle
 *   for future invocations.
 *
 * RETURN:
 *
 *   0              Unsuccessful
 *   non-zero       module handle
 *
 */

SOM_Scope HMODULE  SOMLINK wsf_clsQueryModuleHandle(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_clsQueryModuleHandle");

   /* Return statement to be customized: */
   return;
}

/*
 *
 * METHOD: clsQueryDefaultFileText                        ( ) PRIVATE
 *                                                        (X) PUBLIC
 * DESCRIPTION:
 *
 *   This method returns some default text to stuff in an empty WSFILE.
 *
 * RETURN:
 *
 *   PSZ
 *
 */

SOM_Scope PSZ  SOMLINK wsf_clsQueryDefaultFileText(M_WSFILE *somSelf)
{
    /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
    M_WSFILEMethodDebug("M_WSFILE", "wsf_clsQueryDefaultFileText");

    /* Return statement to be customized: */
    return;
}

SOM_Scope void  SOMLINK wsf_wpclsInitData(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsInitData");

   M_WSFILE_parent_M_WPDataFile_wpclsInitData(somSelf);
}

SOM_Scope void  SOMLINK wsf_wpclsUnInitData(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsUnInitData");

   M_WSFILE_parent_M_WPDataFile_wpclsUnInitData(somSelf);
}

SOM_Scope PSZ  SOMLINK wsf_wpclsQueryTitle(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryTitle");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryTitle(somSelf);
}

SOM_Scope ULONG  SOMLINK wsf_wpclsQueryIconData(M_WSFILE *somSelf,
                                                PICONINFO pIconInfo)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryIconData");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryIconData(somSelf, pIconInfo);
}

SOM_Scope BOOL  SOMLINK wsf_wpclsQueryDefaultHelp(M_WSFILE *somSelf,
                                                  PULONG pHelpPanelId,
                                                  PSZ pszHelpLibrary)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryDefaultHelp");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryDefaultHelp(somSelf,
                                                             pHelpPanelId,
                                                             pszHelpLibrary);
}

SOM_Scope ULONG  SOMLINK wsf_wpclsQueryDefaultView(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryDefaultView");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryDefaultView(somSelf);
}

SOM_Scope ULONG  SOMLINK wsf_wpclsQueryDetailsInfo(M_WSFILE *somSelf,
                                            PCLASSFIELDINFO *ppClassFieldInfo,
                                            PULONG pSize)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryDetailsInfo");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryDetailsInfo(somSelf,
                                                             ppClassFieldInfo,
                                                             pSize);
}

SOM_Scope PSZ  SOMLINK wsf_wpclsQueryInstanceFilter(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryInstanceFilter");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryInstanceFilter(somSelf);
}

SOM_Scope ULONG  SOMLINK wsf_wpclsQueryStyle(M_WSFILE *somSelf)
{
   /* M_WSFILEData *somThis = M_WSFILEGetData(somSelf); */
   M_WSFILEMethodDebug("M_WSFILE", "wsf_wpclsQueryStyle");

   return M_WSFILE_parent_M_WPDataFile_wpclsQueryStyle(somSelf);
}
/***************************** END OF wsfile.c ********************************/
